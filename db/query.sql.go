// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBlog = `-- name: CreateBlog :one
INSERT INTO blogs (title, content, user_id, path)
SELECT $1, $2, $3, $4
WHERE $5 IN (SELECT id FROM users WHERE is_admin = true)
RETURNING id, title, content, user_id, path, modified_at, created_at
`

type CreateBlogParams struct {
	Title   string
	Content string
	UserID  int32
	Path    string
	Column5 interface{}
}

func (q *Queries) CreateBlog(ctx context.Context, arg CreateBlogParams) (Blog, error) {
	row := q.db.QueryRow(ctx, createBlog,
		arg.Title,
		arg.Content,
		arg.UserID,
		arg.Path,
		arg.Column5,
	)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.UserID,
		&i.Path,
		&i.ModifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (address, user_id, is_completed)
VALUES ($1, $2, false)
RETURNING id, address, user_id, is_completed, created_at
`

type CreateOrderParams struct {
	Address string
	UserID  int32
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.Address, arg.UserID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.UserID,
		&i.IsCompleted,
		&i.CreatedAt,
	)
	return i, err
}

const createOrderProduct = `-- name: CreateOrderProduct :one
INSERT INTO order_products (order_id, product_id, quantity)
SELECT $1, $2, $3
WHERE $4 IN (
    SELECT id FROM users 
    WHERE is_admin = true
) OR $4 = (
    SELECT user_id FROM orders 
    WHERE id = $1
)
RETURNING id, order_id, product_id, quantity, created_at
`

type CreateOrderProductParams struct {
	OrderID   int32
	ProductID int32
	Quantity  int32
	Column4   interface{}
}

func (q *Queries) CreateOrderProduct(ctx context.Context, arg CreateOrderProductParams) (OrderProduct, error) {
	row := q.db.QueryRow(ctx, createOrderProduct,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.Column4,
	)
	var i OrderProduct
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    name,
    price,
    image_url,
    is_available
)
SELECT $1, $2, $3, $4
WHERE  $5 IN (SELECT id FROM users WHERE is_admin = true)
RETURNING id, name, price, image_url, is_available, created_at
`

type CreateProductParams struct {
	Name        string
	Price       pgtype.Numeric
	ImageUrl    string
	IsAvailable pgtype.Bool
	Column5     interface{}
}

// Create new product (admin only)
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Price,
		arg.ImageUrl,
		arg.IsAvailable,
		arg.Column5,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.IsAvailable,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, password, email, is_admin)
VALUES ($1, $2, $3, $4)
RETURNING id, name, password, email, is_admin, created_at
`

type CreateUserParams struct {
	Name     string
	Password string
	Email    string
	IsAdmin  pgtype.Bool
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Name,
		arg.Password,
		arg.Email,
		arg.IsAdmin,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBlog = `-- name: DeleteBlog :one
DELETE FROM blogs
WHERE blogs.id = $1
AND ($2 IN (SELECT id FROM users WHERE is_admin = true) OR $2 = blogs.user_id)
RETURNING id, title, content, user_id, path, modified_at, created_at
`

type DeleteBlogParams struct {
	ID      int32
	Column2 interface{}
}

func (q *Queries) DeleteBlog(ctx context.Context, arg DeleteBlogParams) (Blog, error) {
	row := q.db.QueryRow(ctx, deleteBlog, arg.ID, arg.Column2)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.UserID,
		&i.Path,
		&i.ModifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :one
DELETE FROM orders
WHERE orders.id = $1 AND $2 = orders.user_id 
OR $2 IN
(SELECT id FROM users WHERE is_admin = true)
RETURNING id, address, user_id, is_completed, created_at
`

type DeleteOrderParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) DeleteOrder(ctx context.Context, arg DeleteOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, deleteOrder, arg.ID, arg.UserID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.UserID,
		&i.IsCompleted,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrderProduct = `-- name: DeleteOrderProduct :one
DELETE FROM order_products
WHERE order_products.id = $1 AND (
    $2 IN (
        SELECT id FROM users 
        WHERE is_admin = true
    ) 
    OR $2 = (
        SELECT user_id FROM orders 
        WHERE id = (
            SELECT order_id FROM order_products 
            WHERE id = $1
        )
    )
)
RETURNING id, order_id, product_id, quantity, created_at
`

type DeleteOrderProductParams struct {
	ID      int32
	Column2 interface{}
}

func (q *Queries) DeleteOrderProduct(ctx context.Context, arg DeleteOrderProductParams) (OrderProduct, error) {
	row := q.db.QueryRow(ctx, deleteOrderProduct, arg.ID, arg.Column2)
	var i OrderProduct
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :one
DELETE FROM products
WHERE  products.id = $1
  AND  $2 IN (SELECT id FROM users WHERE is_admin = true)
RETURNING id, name, price, image_url, is_available, created_at
`

type DeleteProductParams struct {
	ID      int32
	Column2 interface{}
}

// Delete product (admin only)
func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, deleteProduct, arg.ID, arg.Column2)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.IsAvailable,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :one
DELETE FROM users
WHERE id = $1 AND $2 = $1
RETURNING id, name, password, email, is_admin, created_at
`

type DeleteUserParams struct {
	ID      int32
	Column2 interface{}
}

func (q *Queries) DeleteUser(ctx context.Context, arg DeleteUserParams) (User, error) {
	row := q.db.QueryRow(ctx, deleteUser, arg.ID, arg.Column2)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getBlog = `-- name: GetBlog :one
SELECT id, title, content, user_id, path, modified_at, created_at FROM blogs
WHERE id = $1 LIMIT 1
`

// Blog queries
func (q *Queries) GetBlog(ctx context.Context, id int32) (Blog, error) {
	row := q.db.QueryRow(ctx, getBlog, id)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.UserID,
		&i.Path,
		&i.ModifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getBlogs = `-- name: GetBlogs :many
SELECT id, title, content, user_id, path, modified_at, created_at FROM blogs
`

func (q *Queries) GetBlogs(ctx context.Context) ([]Blog, error) {
	rows, err := q.db.Query(ctx, getBlogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Blog
	for rows.Next() {
		var i Blog
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.UserID,
			&i.Path,
			&i.ModifiedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT id, address, user_id, is_completed, created_at FROM orders
WHERE orders.id = $1
AND (
    orders.user_id = $2
    OR
    $2 IN (SELECT id FROM users WHERE is_admin = true)
)
LIMIT 1
`

type GetOrderParams struct {
	ID     int32
	UserID int32
}

// Order queries
func (q *Queries) GetOrder(ctx context.Context, arg GetOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, arg.ID, arg.UserID)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.UserID,
		&i.IsCompleted,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderProduct = `-- name: GetOrderProduct :one
SELECT id, order_id, product_id, quantity, created_at FROM order_products
WHERE order_products.id = $1 AND (
    $2 IN (
        SELECT id FROM users 
        WHERE is_admin = true
    ) 
    OR $2 = (
        SELECT user_id FROM orders 
        WHERE id = (
            SELECT order_id FROM order_products 
            WHERE id = $1
        )
    )
)
LIMIT 1
`

type GetOrderProductParams struct {
	ID      int32
	Column2 interface{}
}

// Order Product queries
func (q *Queries) GetOrderProduct(ctx context.Context, arg GetOrderProductParams) (OrderProduct, error) {
	row := q.db.QueryRow(ctx, getOrderProduct, arg.ID, arg.Column2)
	var i OrderProduct
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const getOrderProducts = `-- name: GetOrderProducts :many
SELECT id, order_id, product_id, quantity, created_at FROM order_products
WHERE $1 IN (
    SELECT id FROM users 
    WHERE is_admin = true
) OR $1 = (
    SELECT user_id FROM orders 
    WHERE id = order_products.order_id
)
`

func (q *Queries) GetOrderProducts(ctx context.Context, dollar_1 interface{}) ([]OrderProduct, error) {
	rows, err := q.db.Query(ctx, getOrderProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrderProduct
	for rows.Next() {
		var i OrderProduct
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrders = `-- name: GetOrders :many
SELECT id, address, user_id, is_completed, created_at FROM orders
WHERE $1 = orders.user_id 
OR $1 IN
(SELECT id FROM users WHERE is_admin = true)
`

func (q *Queries) GetOrders(ctx context.Context, userID int32) ([]Order, error) {
	rows, err := q.db.Query(ctx, getOrders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.UserID,
			&i.IsCompleted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProduct = `-- name: GetProduct :one

SELECT id, name, price, image_url, is_available, created_at 
FROM   products 
WHERE  id = $1 
LIMIT  1
`

// Product Queries
// -----------------------------------------------------------------------------
// Get a single product by ID
func (q *Queries) GetProduct(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.IsAvailable,
		&i.CreatedAt,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT id, name, price, image_url, is_available, created_at 
FROM   products
`

// Get all products
func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.ImageUrl,
			&i.IsAvailable,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, name, password, email, is_admin, created_at FROM users
WHERE id = $1 LIMIT 1
`

// User queries
func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, name, password, email, is_admin, created_at FROM users
WHERE name = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT id, name, password, email, is_admin, created_at FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Password,
			&i.Email,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlog = `-- name: UpdateBlog :one
UPDATE blogs
SET title = $1, 
    content = $2, 
    user_id = $3,
    path = $4,
    modified_at = CURRENT_TIMESTAMP
WHERE blogs.id = $5 AND ($5 IN (SELECT id FROM users WHERE is_admin = true) OR $5 = $3)
RETURNING id, title, content, user_id, path, modified_at, created_at
`

type UpdateBlogParams struct {
	Title   string
	Content string
	UserID  int32
	Path    string
	ID      int32
}

func (q *Queries) UpdateBlog(ctx context.Context, arg UpdateBlogParams) (Blog, error) {
	row := q.db.QueryRow(ctx, updateBlog,
		arg.Title,
		arg.Content,
		arg.UserID,
		arg.Path,
		arg.ID,
	)
	var i Blog
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.UserID,
		&i.Path,
		&i.ModifiedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET address = $1, 
    user_id = $2,
    is_completed = $3
WHERE orders.id = $4 AND ($5 = orders.user_id OR $5 IN
(SELECT id FROM users WHERE is_admin = true))
RETURNING id, address, user_id, is_completed, created_at
`

type UpdateOrderParams struct {
	Address     string
	UserID      int32
	IsCompleted pgtype.Bool
	ID          int32
	UserID_2    int32
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder,
		arg.Address,
		arg.UserID,
		arg.IsCompleted,
		arg.ID,
		arg.UserID_2,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.UserID,
		&i.IsCompleted,
		&i.CreatedAt,
	)
	return i, err
}

const updateOrderProduct = `-- name: UpdateOrderProduct :one
UPDATE order_products
SET order_id = $1, product_id = $2, quantity = $3
WHERE order_products.id = $4 AND (
    $5 IN (
        SELECT id FROM users 
        WHERE is_admin = true
    ) 
    OR $5 = (
        SELECT user_id FROM orders 
        WHERE id = (
            SELECT order_id FROM order_products 
            WHERE id = $4
        )
    )
)
RETURNING id, order_id, product_id, quantity, created_at
`

type UpdateOrderProductParams struct {
	OrderID   int32
	ProductID int32
	Quantity  int32
	ID        int32
	Column5   interface{}
}

func (q *Queries) UpdateOrderProduct(ctx context.Context, arg UpdateOrderProductParams) (OrderProduct, error) {
	row := q.db.QueryRow(ctx, updateOrderProduct,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.ID,
		arg.Column5,
	)
	var i OrderProduct
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.CreatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET    name = $1,
       price = $2,
       image_url = $3,
       is_available = $4,
       modified_at = CURRENT_TIMESTAMP
WHERE products.id = $5
  AND $6 IN (SELECT id FROM users WHERE is_admin = true)
RETURNING id, name, price, image_url, is_available, created_at
`

type UpdateProductParams struct {
	Name        string
	Price       pgtype.Numeric
	ImageUrl    string
	IsAvailable pgtype.Bool
	ID          int32
	Column6     interface{}
}

// Update existing product (admin only)
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Price,
		arg.ImageUrl,
		arg.IsAvailable,
		arg.ID,
		arg.Column6,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.ImageUrl,
		&i.IsAvailable,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET name = $1, password = $2, email = $3, is_admin = $4
WHERE id = $5 AND $6 = $5
RETURNING id, name, password, email, is_admin, created_at
`

type UpdateUserParams struct {
	Name     string
	Password string
	Email    string
	IsAdmin  pgtype.Bool
	ID       int32
	Column6  interface{}
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Name,
		arg.Password,
		arg.Email,
		arg.IsAdmin,
		arg.ID,
		arg.Column6,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.Email,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}
